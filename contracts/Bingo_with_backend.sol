// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

/// @title Simplified Bingo Game Smart Contract with Off-chain Backend
/// @notice Implements a decentralized Bingo game with backend-generated numbers
contract BingoGame is Pausable, Ownable {

    // Custom errors
    error GameAlreadyInProgress();
    error GameNotInProgress();
    error InvalidCardPurchase();
    error InvalidDrawInterval();
    error InsufficientPlayers();
    error UnauthorizedOperator();
    error InvalidCard();
    error CardAlreadyAssigned();

    // Constants
    uint256 public constant MIN_PLAYERS = 1;
    uint256 public constant N_SIZE = 5;
    uint256 public constant BOARD_SIZE = N_SIZE*N_SIZE;
    uint256 public constant MAX_NUMBER = 99;

    // Storage
    struct BingoCard {
        address owner;
        uint8[25] numbers;
        bool isInit;
        bool hasWon;
    }

    struct GameState {
        uint256 startTime;
        uint256 lastDrawTime;
        uint256[] drawnNumbers;
        bool gameEnded;
    }

    // State variables
    GameState public games;
    mapping(address => BingoCard) public cards;
    mapping(address => bool) private gamePlayers;
    uint256 private gamePlayerCount;
    mapping(uint256 => bool) private usedNumbers;
    address public operator;
    
    // Events
    event GameStarted(uint256 timestamp);
    event CardPurchased(address indexed player);
    event NumberDrawn(uint256 number);
    event WinClaimed(address indexed player);
    event GameEnded(uint256 timestamp);
    event OperatorUpdated(address newOperator);

    /// @notice Initializes the contract with an operator
    constructor(address _operator) Ownable(msg.sender) {
        operator = _operator;
        emit OperatorUpdated(_operator);
    }

    /// @notice Updates the operator address
    function updateOperator(address newOperator) external onlyOwner {
        operator = newOperator;
        emit OperatorUpdated(newOperator);
    }

    modifier onlyOperator() {
        if (msg.sender != operator) {
            revert UnauthorizedOperator();
        }
        _;
    }

    /// @notice Initializes a new game session (internal)
    function _startNewGame() private {
        GameState storage newGame = games;
        newGame.startTime = block.timestamp;
        newGame.lastDrawTime = block.timestamp;
        newGame.gameEnded = false;
        newGame.drawnNumbers = new uint256[](1);
        newGame.drawnNumbers[0] = 0;
        _resetUsedNumbers();
        usedNumbers[0] = true;
        emit GameStarted(block.timestamp);
    }

    function _resetUsedNumbers() private {
        for(uint256 i = 1; i <= MAX_NUMBER; i++) {
            usedNumbers[i] = false;
        }
    }

    /// @notice Assigns a backend-generated card to a player
    /// @param player Player address to assign the card to
    /// @param cardNumbers Numbers generated by the backend
    function assignCard(
        address player,
        uint8[BOARD_SIZE] calldata cardNumbers
    ) external whenNotPaused onlyOperator {
        if (games.startTime > 0) {
            revert GameAlreadyInProgress();
        }
        if (cards[player].isInit) {
            revert CardAlreadyAssigned();
        }

        // Verify card format (only verify middle number is 0)
        require(cardNumbers[BOARD_SIZE/2] == 0, "Invalid middle number");
        
        cards[player] = BingoCard({
            owner: player,
            numbers: cardNumbers,
            hasWon: false,
            isInit: true
        });

        if (!gamePlayers[player]) {
            gamePlayers[player] = true;
            gamePlayerCount++;

            if (gamePlayerCount == MIN_PLAYERS) {
                _startNewGame();
            }
        }

        emit CardPurchased(player);
    }

    /// @notice Draws a new backend-generated number
    /// @param number The number to be drawn
    function submitDrawnNumber(uint256 number) external whenNotPaused onlyOperator {
        GameState storage game = games;
        
        if (game.gameEnded) {
            revert GameNotInProgress();
        }
        if (gamePlayerCount < MIN_PLAYERS) {
            revert InsufficientPlayers();
        }
        if (number > MAX_NUMBER || number == 0) {
            revert InvalidDrawInterval();
        }
        if (usedNumbers[number]) {
            revert InvalidDrawInterval();
        }

        game.drawnNumbers.push(number);
        usedNumbers[number] = true;
        game.lastDrawTime = block.timestamp;

        emit NumberDrawn(number);

        if (game.drawnNumbers.length >= MAX_NUMBER) {
            endGame();
        }
    }

    function getPlayerCards() external view returns (uint8[25] memory storedNumbers) {
        require(cards[msg.sender].isInit, "No card!");
        storedNumbers = cards[msg.sender].numbers;
        return storedNumbers;
    }

    function claimWin() external whenNotPaused returns (bool) {
        BingoCard storage card = cards[msg.sender];

        if (card.owner != msg.sender || card.hasWon) {
            return false;
        }
        if (!_verifyWin(card)) {
            return false;
        }
        card.hasWon = true;
        emit WinClaimed(msg.sender);
        endGame();
        return true;
    }

    function endGame() public whenNotPaused {
        GameState storage game = games;
        
        if (game.gameEnded) {
            revert GameNotInProgress();
        }

        game.gameEnded = true;
        emit GameEnded(block.timestamp);
    }

    function _verifyWin(BingoCard memory card) public view returns (bool) {
        // Check rows
        for (uint256 i = 0; i < N_SIZE; i++) {
            bool rowWin = true;
            for (uint256 j = 0; j < N_SIZE; j++) {
                if (!usedNumbers[card.numbers[i * N_SIZE + j]]) {
                    rowWin = false;
                    break;
                }
            }
            if (rowWin) return true;
        }
        
        // Check columns
        for (uint256 i = 0; i < N_SIZE; i++) {
            bool colWin = true;
            for (uint256 j = 0; j < N_SIZE; j++) {
                if (!usedNumbers[card.numbers[j * N_SIZE + i]]) {
                    colWin = false;
                    break;
                }
            }
            if (colWin) return true;
        }
        
        // Check diagonals
        bool diag1Win = true;
        bool diag2Win = true;
        for (uint256 i = 0; i < N_SIZE; i++) {
            if (!usedNumbers[card.numbers[i * N_SIZE + i]]) {
                diag1Win = false;
            }
            if (!usedNumbers[card.numbers[i * N_SIZE + (N_SIZE-1 - i)]]) {
                diag2Win = false;
            }
            if (!diag1Win && !diag2Win) break;
        }
        
        return diag1Win || diag2Win;
    }

    // View functions
    function getDrawnNumbers() external view returns (uint256[] memory) {
        return games.drawnNumbers;
    }

    function getCurrentGameState() external view returns (
        uint256 startTime,
        uint256 lastDrawTime,
        uint256 numberCount,
        uint256[] memory drawnNumbers,
        bool isEnded,
        uint256 playerCount,
        bool isStarted
    ) {
        GameState storage game = games;
        return (
            game.startTime,
            game.lastDrawTime,
            game.drawnNumbers.length,
            game.drawnNumbers,
            game.gameEnded,
            gamePlayerCount,
            gamePlayerCount >= MIN_PLAYERS
        );
    }

    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }

    function isInGame() external view returns (bool) {
        return gamePlayers[msg.sender];
    }

    function getCurrentPlayerCount() external view returns (uint256) {
        return gamePlayerCount;
    }

    function getRemainingPlayerCount() external view returns (uint256) {
        return MIN_PLAYERS-gamePlayerCount;
    }
}